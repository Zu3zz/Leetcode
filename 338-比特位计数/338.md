# 338. 比特位计数

- 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

1. 示例 1：

```shell
输入: 2
输出: [0,1,1]
```

2. 示例 2：

```shell
输入: 5
输出: [0,1,1,2,1,2]
```

- 进阶:

  - 给出时间复杂度为 O(n\*sizeof(integer))的解答非常容易。但你可以在线性时间 O(n)内用一趟扫描做到吗？
  - 要求算法的空间复杂度为 O(n)。
  - 你能进一步完善解法吗？要求在 C++或任何其他语言中不使用任何内置函数（如 C++ 中的  \_\_builtin_popcount）来执行此操作。

## Solution

1. 两次循环，i 每次走的距离都依次翻倍，从 2 到 4 到 8 再到 16
2. j 用来计数，将上一轮循环的除了首位的结果加上这一轮首数字为 1 的情况
